0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014
0004   0000             ; Fabio Belavenuto
0005   0000             ;
0006   0000             ; Baseado no código FL2 versão 2.2 de 29-12-2002  (c) Ramones 2002
0007   0000             ;
0008   0000             ;
0009   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0010   0000             ; You may redistribute and modify this documentation under the terms of the
0011   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0012   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0013   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0014   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0015   0000             
0016   0000             
0017   0000             	output	"sdmupd.com"
0018   0000             
0019   0000             	include	"bios.inc"
0001+  0000             ;
0002+  0000             ; BIOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             PSLTRG			= $A8			; I/O port address of primary slot register
0006+  0000             
0007+  0000             WBOOT			= $00
0008+  0000             RDSLT			= $0C
0009+  0000             WRSLT			= $14
0010+  0000             CALSTL			= $1C
0011+  0000             ENASLT			= $24
0012+  0000             IDBYT0			= $2B
0013+  0000             BASVER			= $2D
0014+  0000             CALLF			= $30
0015+  0000             KEYINT			= $38
0016+  0000             WRTVDP			= $47
0017+  0000             LDIRMV			= $59
0018+  0000             LDIRVM			= $5C
0019+  0000             CHGMOD			= $5F
0020+  0000             INITXT			= $6C
0021+  0000             CHSNS			= $9C
0022+  0000             CHGET			= $9F
0023+  0000             CHPUT			= $A2
0024+  0000             LPTOUT			= $A5
0025+  0000             BREAKX			= $B7
0026+  0000             CKCNTC			= $BD
0027+  0000             ERAFNK			= $CC
0028+  0000             TOTEXT			= $D2
0029+  0000             SNSMAT			= $141
0030+  0000             PHYDIO			= $144
0031+  0000             KILBUF			= $156
0032+  0000             CALBAS			= $159
0033+  0000             EXTROM			= $15F
0034+  0000             
0035+  0000             RDPRIM			= $F380
0036+  0000             WRPRIM			= $F385
0037+  0000             CLPRIM			= $F38C
0038+  0000             CLPRM1			= $F398
0039+  0000             LINL40			= $F3AE
0040+  0000             LINLEN			= $F3B0
0041+  0000             CNSDFG			= $F3DE
0042+  0000             LPTPOS			= $F415
0043+  0000             PRTFLG			= $F416
0044+  0000             CURLIN			= $F41C
0045+  0000             KBUF			= $F41F
0046+  0000             BUF				= $F55E
0047+  0000             TTYPOS			= $F661
0048+  0000             VALTYP			= $F663
0049+  0000             MEMSIZ			= $F672
0050+  0000             STKTOP			= $F674
0051+  0000             TXTTAB			= $F676
0052+  0000             TEMPPT			= $F678
0053+  0000             TEMPST			= $F67A
0054+  0000             DSCTMP			= $F698
0055+  0000             FRETOP			= $F69B
0056+  0000             AUTLIN			= $F6AB
0057+  0000             SAVSTK			= $F6B1
0058+  0000             VARTAB			= $F6C2
0059+  0000             STREND			= $F6C6
0060+  0000             DAC				= $F7F6
0061+  0000             ARG				= $F847
0062+  0000             MAXFIL			= $F85F
0063+  0000             FILTAB			= $F860
0064+  0000             NULBUF			= $F862
0065+  0000             PTRFIL			= $F864
0066+  0000             FILNAM			= $F866
0067+  0000             NLONLY			= $F87C
0068+  0000             SAVEND			= $F87D
0069+  0000             EXBRSA			= $FAF0
0070+  0000             HOKVLD			= $FB20
0071+  0000             YFB21			= $FB21					; diskdriver table
0072+  0000             YFB29			= $FB29					; diskdriver interrupt table
0073+  0000             BOTTOM			= $FC48
0074+  0000             HIMEM			= $FC4A
0075+  0000             CSRSW			= $FCA9
0076+  0000             FLBMEM			= $FCAE
0077+  0000             RUNBNF			= $FCBE
0078+  0000             SAVENT			= $FCBF
0079+  0000             EXPTBL			= $FCC1					; slots expanded or not
0080+  0000             SLTTBL			= $FCC5
0081+  0000             SLTATR			= $FCC9
0082+  0000             SLTWRK			= $FD09
0083+  0000             PROCNM			= $FD89
0084+  0000             DEVICE			= $FD99
0085+  0000             H.TIMI			= $FD9F
0086+  0000             H.KEYI			= $FD9A					; interrupt hook
0087+  0000             H.DSKO			= $FDEF
0088+  0000             H.NAME			= $FDF9
0089+  0000             H.KILL			= $FDFE
0090+  0000             H.COPY			= $FE08
0091+  0000             H.DSKF			= $FE12
0092+  0000             H.DSKI			= $FE17
0093+  0000             H.LSET			= $FE21
0094+  0000             H.RSET			= $FE26
0095+  0000             H.FIEL			= $FE2B
0096+  0000             H.MKI			= $FE30
0097+  0000             H.MKS			= $FE35
0098+  0000             H.MKD			= $FE3A
0099+  0000             H.CVI			= $FE3F
0100+  0000             H.CVS			= $FE44
0101+  0000             H.CVD			= $FE49
0102+  0000             H.GETP			= $FE4E
0103+  0000             H.NOFO			= $FE58
0104+  0000             H.NULO			= $FE5D
0105+  0000             H.NTFL			= $FE62
0106+  0000             H.BINS			= $FE71
0107+  0000             H.BINL			= $FE76
0108+  0000             H.FILE			= $FE7B
0109+  0000             H.DGET			= $FE80
0110+  0000             H.FILO			= $FE85
0111+  0000             H.INDS			= $FE8A
0112+  0000             H.LOC			= $FE99
0113+  0000             H.LOF			= $FE9E
0114+  0000             H.EOF			= $FEA3
0115+  0000             H.BAKU			= $FEAD
0116+  0000             H.PARD			= $FEB2
0117+  0000             H.NODE			= $FEB7
0118+  0000             H.POSD			= $FEBC
0119+  0000             H.RUNC			= $FECB
0120+  0000             H.CLEA			= $FED0
0121+  0000             H.LOPD			= $FED5
0122+  0000             H.STKE			= $FEDA
0123+  0000             H.ERRP			= $FEFD
0124+  0000             H.PHYD			= $FFA7
0125+  0000             H.FORM			= $FFAC
0126+  0000             EXTBIO			= $FFCA
0127+  0000             DISINT			= $FFCF
0128+  0000             ENAINT			= $FFD4
0129+  0000             EXTVDP			= $FFE7
0130+  0000             
0020   0000             	include	"bdos.inc"
0001+  0000             ;
0002+  0000             ; MSX-DOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             BDOS			= 5
0006+  0000             
0007+  0000             	MACRO BdosCall function
0008+  0000~            		ld		c, function
0009+  0000~            		call	BDOS
0010+  0000             	ENDM
0011+  0000             
0012+  0000             _TERM0			= $00					; Program terminate
0013+  0000             _CONIN			= $01					; Console input
0014+  0000             _CONOUT			= $02					; Console output
0015+  0000             _AUXIN			= $03					; Auxiliary input
0016+  0000             _AUXOUT			= $04					; Auxiliary output
0017+  0000             _LSTOUT			= $05					; Printer output
0018+  0000             _DIRIO			= $06					; Direct console I/O
0019+  0000             _DIRIN			= $07					; Direct console input
0020+  0000             _INNOE			= $08					; Console input without echo
0021+  0000             _STROUT			= $09					; String output
0022+  0000             _BUFIN			= $0A					; Buffered line input
0023+  0000             _CONST			= $0B					; Console status
0024+  0000             _CPMVER			= $0C					; Return version number
0025+  0000             _DSKRST			= $0D					; Disk reset
0026+  0000             _SELDSK			= $0E					; Select disk
0027+  0000             _FOPEN			= $0F					; Open file
0028+  0000             _FCLOSE			= $10					; Close file
0029+  0000             _SFIRST			= $11					; Search for first
0030+  0000             _SNEXT			= $12					; Search for next
0031+  0000             _FDEL			= $13					; Delete file
0032+  0000             _RDSEQ			= $14					; Sequencial read
0033+  0000             _WRSEQ			= $15					; Sequencial write
0034+  0000             _FMAKE			= $16					; Create file
0035+  0000             _FREN			= $17					; Rename file
0036+  0000             _LOGIN          = $18					; Get login vector
0037+  0000             _CURDRV			= $19					; Get current drive
0038+  0000             _SETDTA			= $1A					; Set disk transfer address
0039+  0000             _ALLOC			= $1B					; Get allocation information
0040+  0000             _RDRND			= $21					; Random read
0041+  0000             _WRRND			= $22					; Random write
0042+  0000             _FSIZE			= $23					; Get file size
0043+  0000             _SETRND			= $24					; Set random record
0044+  0000             _WRBLK			= $26					; Random block write
0045+  0000             _RDBLK			= $27					; Random block read
0046+  0000             _WRZER			= $28					; Random write with zero fill
0047+  0000             _GDATE			= $2A					; Get date
0048+  0000             _SDATE			= $2B					; Set date
0049+  0000             _GTIME			= $2C					; Get time
0050+  0000             _STIME			= $2D					; Set time
0051+  0000             _VERIFY			= $2E					; Set/reset verify flag
0052+  0000             _RDABS			= $2F					; Absolute sector read
0053+  0000             _WRABS			= $30					; Absolute sector write
0054+  0000             _DPARM			= $31					; Get disk parameters
0055+  0000             _FFIRST			= $40					; Find first entry
0056+  0000             _FNEXT			= $41					; Find next entry
0057+  0000             _FNEW			= $42					; Find = entry
0058+  0000             _OPEN			= $43					; Open file handle
0059+  0000             _CREATE			= $44					; Create file handle
0060+  0000             _CLOSE			= $45					; Close file handle
0061+  0000             _ENSURE			= $46					; Ensure file handle
0062+  0000             _DUP			= $47					; Duplicate file handle
0063+  0000             _READ			= $48					; Read from file handle
0064+  0000             _WRITE			= $49					; Write to file handle
0065+  0000             _SEEK			= $4A					; Move file handle pointer
0066+  0000             _IOCTL			= $4B					; I/O control for devices
0067+  0000             _HTEST			= $4C					; Test file handle
0068+  0000             _DELETE			= $4D					; Delete file or subdirectory
0069+  0000             _RENAME			= $4E					; Rename file or subdirectory
0070+  0000             _MOVE			= $4F					; Move file or subdirectory
0071+  0000             _ATTR			= $50					; Get/set file attributes
0072+  0000             _FTIME			= $51					; Get/set file date and time
0073+  0000             _HDELETE		= $52					; Delete file handle
0074+  0000             _HRENAME		= $53					; Rename file handle
0075+  0000             _HMOVE			= $54					; Move file handle
0076+  0000             _HATTR			= $55					; Get/set file handle attributes
0077+  0000             _HFTIME			= $56					; Get/set file handle date and time
0078+  0000             _GETDTA			= $57					; Get disk transfer address
0079+  0000             _GETVFY			= $58					; Get verify flag setting
0080+  0000             _GETCD			= $59					; Get current directory
0081+  0000             _CHDIR			= $5A					; Change current directory
0082+  0000             _PARSE			= $5B					; Parse pathname
0083+  0000             _PFILE			= $5C					; Parse filename
0084+  0000             _CHKCHR			= $5D					; Check character
0085+  0000             _WPATH			= $5E					; Get whole path string
0086+  0000             _FLUSH			= $5F					; Flush disk buffers
0087+  0000             _FORK			= $60					; Fork a child process
0088+  0000             _JOIN			= $61					; Rejoin parent process
0089+  0000             _TERM			= $62					; Terminate with error code
0090+  0000             _DEFAB			= $63					; Define abort exit routine
0091+  0000             _DEFER			= $64					; Define disk error handler routine
0092+  0000             _ERROR			= $65					; GFet previous error code
0093+  0000             _EXPLAIN		= $66					; Explain error code
0094+  0000             _FORMAT			= $67					; Format a disk
0095+  0000             _RAMD			= $68					; Create or destroy RAM disk
0096+  0000             _BUFFER			= $69					; Allocate sector buffers
0097+  0000             _ASSGIN			= $6A					; Logical drive assignment
0098+  0000             _GENV			= $6B					; Get environment item
0099+  0000             _SENV			= $6C					; Set environment item
0100+  0000             _FENV			= $6D					; Find environment item
0101+  0000             _DSKCHK			= $6E					; Get/set disk check status
0102+  0000             _DOSVER			= $6F					; Get MSX DOS version number
0103+  0000             _REDIR			= $70					; Get/set redirection status
0104+  0000             
0105+  0000             ; Errors
0106+  0000             ERROR: 
0107+  0000             .NCOMP			= $FF					; Incompatible disk
0108+  0000             .WRERR			= $FE					; Write error
0109+  0000             .DISK			= $FD					; Disk error
0110+  0000             .NRDY			= $FC					; Not ready
0111+  0000             .VERFY			= $FB					; Verify error
0112+  0000             .DATA			= $FA					; Data error
0113+  0000             .RNF			= $F9					; Sector not found
0114+  0000             .WPROT			= $F8					; Write protected disk
0115+  0000             .UFORM			= $F7					; Unformatted disk
0116+  0000             .NDOS			= $F6					; Not a DOS disk
0117+  0000             .WDISK			= $F5					; Wrong disk
0118+  0000             .WFILE			= $F4					; Wrong disk for file
0119+  0000             .SEEK			= $F3					; Seek error
0120+  0000             .IFAT			= $F2					; Bad file allocation table
0121+  0000             .NOUPB			= $F1					; --
0122+  0000             .IFORM			= $F0					; Cannot format this drive
0123+  0000             .INTER			= $DF					; Internal error
0124+  0000             .NORAM			= $DE					; Not enough memory
0125+  0000             .IBDOS			= $DC					; Invalid MSX-DOS call
0126+  0000             .IDRV			= $DB					; Invalid drive
0127+  0000             .IFNM			= $DA					; Invalid filename
0128+  0000             .IPATH			= $D9					; Invalid pathname
0129+  0000             .PLONG			= $D8					; Pathname too long
0130+  0000             .NOFIL			= $D7					; File not found
0131+  0000             .NODIR			= $D6					; Directory not found
0132+  0000             .DRFUL			= $D5					; Root directory full
0133+  0000             .DKFUL			= $D4					; Disk full
0134+  0000             .DUPF			= $D3					; Duplicate filename
0135+  0000             .DIRE			= $D2					; Invalid directory move
0136+  0000             .FILRO			= $D1					; Read only file
0137+  0000             .DIRNE			= $D0					; Directory not empty
0138+  0000             .IATTR			= $CF					; Invalid attributes
0139+  0000             .DOT			= $CE					; Invalid . or .. operation
0140+  0000             .SYSX			= $CD					; System file exists
0141+  0000             .DIRX			= $CC					; Directory exists
0142+  0000             .FILEX			= $CB					; File exists
0143+  0000             .FOPEN			= $CA					; File already in use
0144+  0000             .OV64K			= $C9					; Cannot transfer above 64K
0145+  0000             .FILE			= $C8					; File allocation error
0146+  0000             .EOF			= $C7					; End of file
0147+  0000             .ACCV			= $C6					; File access violation
0148+  0000             .IPROC			= $C5					; Invalid process id
0149+  0000             .NHAND			= $C4					; No spare file handles
0150+  0000             .IHAND			= $C3					; Invalid file handle
0151+  0000             .NOPEN			= $C2					; File handle not open
0152+  0000             .IDEV			= $C1					; Invalid device operation
0153+  0000             .IENV			= $C0					; Invalid environment string
0154+  0000             .ELONG			= $BF					; Environment string too long
0155+  0000             .IDATE			= $BE					; Invalid date
0156+  0000             .ITIME			= $BD					; Invalid time
0157+  0000             .RAMDX			= $BC					; RAM disk (drive H ) already exists
0158+  0000             .NRAMD			= $BB					; RAM disk does not exist
0159+  0000             .HDEAD			= $BA					; File handle has been deleted
0160+  0000             .EOL			= $B9					; Internal error. Should never occur
0161+  0000             .ISBFN			= $B8					; Invalid sub-function number
0162+  0000             .STOP			= $9F					; Ctrl-STOP pressed
0163+  0000             .CTRLC			= $9E					; Ctrl-C pressed
0164+  0000             .ABORT			= $9D					; Disk operation aborted
0165+  0000             .OUTERR			= $9C					; Error on standard output
0166+  0000             .INERR			= $9B					; Error on standard input
0167+  0000             .BADCOM			= $8F					; Wrong version of COMMAND
0168+  0000             .BADCM			= $8E					; Unrecognized command
0169+  0000             .BUFUL			= $8D					; Command too long
0170+  0000             .OKCMD			= $8C					; --
0171+  0000             .IPARM			= $8B					; Invalid parameter
0172+  0000             .INP			= $8A					; Too many parameters
0173+  0000             .NOPAR			= $89					; Missing parameter
0174+  0000             .IOPT			= $88					; Invalid option
0175+  0000             .BADNO			= $87					; Invalid number
0176+  0000             .NOHELP			= $86					; File for HELP not found
0177+  0000             .BADVER			= $85					; Wrong version of MSX-DOS
0178+  0000             .NOCAT			= $84					; Cannot concatenate destination file
0179+  0000             .BADEST			= $83					; Cannot create destination file
0180+  0000             .COPY			= $82					; File cannot be copied onto itself
0181+  0000             .OVDEST			= $81					; Cannot overwrite previous destination file
0182+  0000             
0183+  0000             ; Allocate segment parameters
0184+  0000             USER_SEGMENT		= 0					; Register A
0185+  0000             SYSTEM_SEGMENT		= 1					; "        "
0186+  0000             PRIMARY_MAPPER		= 0					; Register B 
0187+  0000             
0188+  0000             ; Open file flags (_OPEN)
0189+  0000             OPEN_NO_WRITE		= 1
0190+  0000             OPEN_NO_READ		= 2
0191+  0000             OPEN_INHERITABLE	= 4
0192+  0000             
0193+  0000             ; Seek file flags
0194+  0000             SEEK_SET			= 0
0195+  0000             SEEK_CUR			= 1
0196+  0000             SEEK_END			= 2
0197+  0000             
0198+  0000             ; File attributes (bit mask)
0199+  0000             FILE_READ_ONLY		= 1					; 
0200+  0000             FILE_HIDDEN			= 2					;
0201+  0000             FILE_SYSTEM			= 4					; 
0202+  0000             FILE_VOLUME_NAME	= 8					; 
0203+  0000             FILE_DIRECTORY		= 16				; 
0204+  0000             FILE_ARCHIVE		= 32				; 
0205+  0000             FILE_RESERVED		= 64				; 
0206+  0000             FILE_DEVICE			= 128				;
0207+  0000             
0208+  0000             ; Disk error handler routine parameters in register C
0209+  0000             ERROR_WRITING		= 1					; Set if writing
0210+  0000             ERROR_NO_IGNORE		= 2					; Set if ignore not recommended
0211+  0000             ERROR_AUTO_ABORT	= 4					; Set if auto-abort suggested
0212+  0000             ERROR_VALID_SECTOR	= 8					; Set if sector number is valid 
0213+  0000             
0214+  0000             
0215+  0000             ; Disk error handler routine return codes
0216+  0000             CALL_SYSTEM_ERROR	= 0					; Call system error routine
0217+  0000             ERROR_ABORT			= 1					; Abort
0218+  0000             ERROR_RETRY			= 2					; Retry
0219+  0000             ERROR_IGNORE		= 3					; Ignore
0220+  0000             
0221+  0000             
0222+  0000             ;  Params _RAMD
0223+  0000             DESTROY_RAMDISK		= 0
0224+  0000             GET_RAMDISK_SIZE	= $FF
0225+  0000             CREATE_RAMDISK		= 1					; CREATE_RAMDISK+n = 1+n
0226+  0000             
0227+  0000             ; Misc
0228+  0000             CR					= 13				; Carridge Return
0229+  0000             LF					= 10				; Line Feed
0230+  0000             LE					= '$'				; Line end
0231+  0000             UPPER_CASE_MASK		= $DF
0232+  0000             
0233+  0000             CMD_LENGTH			= $80
0234+  0000             CMD_LINE			= $82
0235+  0000             
0236+  0000             COM_START_ADDR		= $100
0237+  0000             
0238+  0000             RAMAD0				= $F341				; slotid DOS ram page 0
0239+  0000             RAMAD1				= $F342				; slotid DOS ram page 1
0240+  0000             RAMAD2				= $F343				; slotid DOS ram page 2
0241+  0000             RAMAD3				= $F344				; slotid DOS ram page 3
0242+  0000             SECBUF				= $F34D				; pointer to sectorbuffer, can be used by the diskdriver
0243+  0000             
0021   0000             
0022   0000             
0023   0000             	org		COM_START_ADDR
0024   0100             
0025   0100             
0026   0100             ; *** CONSTANTS ***
0027   0100             IOFW		= $5F						; Porta de controle para gravacao da flash
0028   0100             ALG_BYTE	= 1
0029   0100             ALG_PAGE	= 2
0030   0100             
0031   0100             inicio: 
0032   0100             
0033   0100             ; **** MAIN PROGRAM ****
0034   0100             
0035   0100             init: 
0036   0100             	; Actual parameters saved
0037   0100 ED 73 F0 09 	ld		(savesp), sp				; Stack Pointer saved
0038   0104 3A A9 FC    	ld		a, (CSRSW)					; Cursor Saved
0039   0107 32 F3 09    	ld		(savecursor), a
0040   010A CD F1 04    	call	cursorOff         			; Turn cursor off (no matter about its state)
0041   010D             
0042   010D 11 85 06    	ld		de, strTitulo
0043   0110 CD 3E 05    	call	print						; Print logo
0044   0113             
0045   0113 CD CF 01    	call	checkDOS					; Dos version checked
0046   0116 CD D9 01    	call	checkSystem					; MSX Type checked
0047   0119 CD 06 02    	call	checkParams					; Check and Save parameters
0048   011C             
0049   011C 3A F6 09    	ld		a, (options)
0050   011F CB 4F       	bit		1, a						; only list chips?
0051   0121 C2 F9 05    	jp		nz, showList				; yes, jump
0052   0124             
0053   0124 CD 3B 01    	call	checkFlash     				; Search FLASH ROM
0054   0127             
0055   0127 3A F6 09    	ld		a, (options)
0056   012A CB 47       	bit		0, a						; only erasing flash?
0057   012C C2 A1 04    	jp		nz, eraseFlash				; yes, jump to erase it
0058   012F             
0059   012F CD A7 02    	call	checkFile					; Checks if file-argument exists and your size
0060   0132 CD A1 04    	call	eraseFlash					; Erase flash.
0061   0135 CD 15 03    	call	loadFile 					; Load file in flash
0062   0138             
0063   0138 C3 0F 05    	jp		exitok						; No. Exit Program
0064   013B             
0065   013B             
0066   013B             ; *** CHECKING ROUTINES ***
0067   013B             
0068   013B             ; -------------------
0069   013B             ; checkFlash
0070   013B             ; Searches FLASH ROM
0071   013B             ; ------------------
0072   013B             checkFlash: 
0073   013B 11 9B 07    	ld		de, strProcuraFlash
0074   013E CD 3E 05    	call	print						; Prints searching message
0075   0141 3E FF       	ld		a, $FF
0076   0143 32 F9 09    	ld		(thisslt), a				; Inits SIGSLOT Routine
0077   0146             .loop: 
0078   0146 F3          	di
0079   0147 CD CA 03    	call	sigslot						; Calls the next slot (first one if first time)
0080   014A FE FF       	cp		$FF							; Is it the last slot?
0081   014C 28 44       	jr		z, .naoachado				; Yes. FLASH was not found
0082   014E 26 80       	ld		h, $80						; It is not the last slot. Placed it in page 2
0083   0150 CD 24 00    	call	ENASLT
0084   0153 CD A0 01    	call	checkDeviceID				; Searching flash by executing its ID_CHECK command
0085   0156 38 EE       	jr		c, .loop					; Not found in this slot, continue with next one
0086   0158             
0087   0158 3A F9 09    	ld		a, (thisslt)				; FLASH WAS FOUND
0088   015B 32 FA 09    	ld		(flashslt), a				; Slot saved
0089   015E F5          	push	af 							; For printing the message of slot / subslot
0090   015F E6 03       	and		3
0091   0161 C6 30       	add		a, '0'      				; ASCII conversion of the Slot
0092   0163 32 EB 07    	ld		(strAchado.slot), a
0093   0166 F1          	pop		af
0094   0167 0F          	rrca
0095   0168 0F          	rrca
0096   0169 E6 03       	and		3
0097   016B C6 30       	add		a, '0'
0098   016D 32 F5 07    	ld		(strAchado.subslot), a		; ASCII conversion of the Subslot.
0099   0170             
0100   0170 3A 43 F3    	ld		a, (RAMAD2)
0101   0173 26 80       	ld		h, $80
0102   0175 CD 24 00    	call	ENASLT						; Restoring page 2 (Memory again)
0103   0178             
0104   0178 11 DD 07    	ld		de, strAchado
0105   017B CD 3E 05    	call	print						; Printing message with info about slot / subslot
0106   017E ED 5B FE 09 	ld		de, (flashManPoint)			; recuperamos string do fabricante
0107   0182 CD 3E 05    	call	print
0108   0185 ED 5B 00 0A 	ld		de, (flashProdPoint)		; recuperamos string do produto
0109   0189 CD 3E 05    	call	print						; e imprimimos
0110   018C 11 C5 06    	ld		de, strCrLf
0111   018F C3 3E 05    	jp		print
0112   0192             
0113   0192             .naoachado: 								; FLASH NOT FOUND
0114   0192 3A 43 F3    	ld		a, (RAMAD2)
0115   0195 26 80       	ld		h, $80
0116   0197 CD 24 00    	call	ENASLT						; Memory placed
0117   019A 11 BF 07    	ld		de, strNaoAchado
0118   019D C3 0A 05    	jp		printErro					; Error message, exiting program
0119   01A0             
0120   01A0             ; ------------------------
0121   01A0             ; checkDeviceID
0122   01A0             ; Check Flash Manufacturer and Device ID
0123   01A0             ; Z = 1 if Flash found
0124   01A0             ;
0125   01A0             ; -------------------------
0126   01A0             checkDeviceID: 
0127   01A0 F3          	di
0128   01A1 3E F0       	ld		a, $F0						; Comando $F0 (Reset)
0129   01A3 CD 2B 04    	call	flashSendCommand2
0130   01A6 3E 90       	ld		a, $90						; Comando $90 (Software ID Entry)
0131   01A8 CD 2B 04    	call	flashSendCommand2
0132   01AB 3A 00 80    	ld		a, ($8000)					; Ler Manufacturer ID
0133   01AE 32 FB 09    	ld		(flashIdMan), a				; e salvar
0134   01B1 3A 01 80    	ld		a, ($8001)					; Ler Product ID
0135   01B4 32 FC 09    	ld		(flashIdProd), a			; e salvar
0136   01B7 CD 43 06    	call	flashIdent					; chamamos funcao que identifica flash
0137   01BA 3A FD 09    	ld		a, (flashAlg)
0138   01BD FE 00       	cp		0
0139   01BF 37          	scf									; Carry = 1 - erro
0140   01C0 28 01       	jr		z, .sair					; se A for zero nao identificamos
0141   01C2             .ok: 
0142   01C2 AF          	xor		a							; Carry = 0 - OK
0143   01C3             .sair: 
0144   01C3 F5          	push	af
0145   01C4 3E F0       	ld		a, $F0						; Comando $F0 (Reset)
0146   01C6 CD 2B 04    	call	flashSendCommand2
0147   01C9 AF          	xor		a
0148   01CA D3 5F       	out		(IOFW), a					; Desliga modo gravacao da Flash
0149   01CC F1          	pop		af
0150   01CD FB          	ei
0151   01CE C9          	ret
0152   01CF             
0153   01CF             ; ----------------------
0154   01CF             ; CHECK DOS
0155   01CF             ; check operating system
0156   01CF             ; ----------------------
0157   01CF             checkDOS: 
0158   01CF 0E 6F       	ld		c, _DOSVER
0159   01D1 CD 02 05    	call	callBdos					; Send DOSVER command to dos
0160   01D4 78          	ld		a, b
0161   01D5 32 F4 09    	ld		(dos), a					; Save dos version
0162   01D8 C9          	ret
0163   01D9             
0164   01D9             ; ----------------
0165   01D9             ; checkSystem
0166   01D9             ; check MSX
0167   01D9             ; ----------------
0168   01D9             checkSystem: 
0169   01D9 3A C1 FC    	ld		a, (EXPTBL)
0170   01DC 21 2D 00    	ld		hl, BASVER
0171   01DF CD 0C 00    	call	RDSLT						; Check byte $2D (MSX version)
0172   01E2 32 F5 09    	ld		(system), a
0173   01E5 FE 03       	cp		3							; Turbo R?
0174   01E7 D8          	ret	c								; no, return
0175   01E8 FD 2A C0 FC 	ld		iy, (EXPTBL - 1)			; is MSX Turbo R
0176   01EC DD 21 83 01 	ld		ix, $183
0177   01F0 CD 1C 00    	call	CALSTL
0178   01F3 F6 80       	or		$80
0179   01F5 32 F2 09    	ld		(savecpu), a				; save actual CPU mode
0180   01F8 3E 80       	ld		a, $80						; and set Z80 for compatibility
0181   01FA             
0182   01FA             systemSetCPU: 
0183   01FA FD 2A C0 FC 	ld		iy, (EXPTBL - 1)
0184   01FE DD 21 80 01 	ld		ix, $180
0185   0202 CD 1C 00    	call	CALSTL
0186   0205 C9          	ret
0187   0206             
0188   0206             ; --------------------
0189   0206             ; checkParams
0190   0206             ; Check line params
0191   0206             ; --------------------
0192   0206             checkParams: 
0193   0206 21 80 00    	ld		hl, CMD_LENGTH
0194   0209 7E          	ld		a, (hl)
0195   020A B7          	or		a							; Parameters?
0196   020B 11 C8 06    	ld		de, strHelp
0197   020E CA 0A 05    	jp		z, printErro				; no parameters. Show Help and exit
0198   0211             
0199   0211 CD 6B 02    	call	checkOptions				; Check parameter options
0200   0214 CD 39 02    	call	checkFileName				; Check file name
0201   0217             
0202   0217 3A F4 09    	ld		a, (dos)
0203   021A FE 02       	cp		2
0204   021C D2 87 03    	jp		nc, fillName				; If DOS2 then fill only the name
0205   021F 21 09 0A    	ld		hl, fileNameDOS2			; DOS1. Extract filename
0206   0222 11 49 0A    	ld		de, fileNameDOS1
0207   0225             .loop0: 
0208   0225 7E          	ld		a,(hl)
0209   0226 FE 2E       	cp		'.'
0210   0228 28 08       	jr		z, .loop2
0211   022A 12          	ld		(de), a
0212   022B 13          	inc		de
0213   022C             .loop1: 
0214   022C 23          	inc		hl
0215   022D 10 F6       	djnz	.loop0
0216   022F C3 87 03    	jp		fillName
0217   0232             .loop2: 
0218   0232 11 51 0A    	ld		de, filenDOS1Ext
0219   0235 06 04       	ld		b, 4
0220   0237 18 F3       	jr		.loop1
0221   0239             
0222   0239             ; -------------------
0223   0239             ; checkFileName
0224   0239             ; Extract the name of
0225   0239             ; the parameters in
0226   0239             ; DOS2 format
0227   0239             ; ------------------
0228   0239             checkFileName: 
0229   0239 3A 80 00    	ld		a, (CMD_LENGTH)
0230   023C FE 01       	cp		1
0231   023E 47          	ld		b, a
0232   023F 28 01       	jr		z, .p1
0233   0241 05          	dec		b
0234   0242             .p1: 
0235   0242 21 82 00    	ld		hl, CMD_LINE
0236   0245 11 09 0A    	ld		de, fileNameDOS2
0237   0248 0E 00       	ld		c, 0
0238   024A             .loop0: 
0239   024A 7E          	ld		a, (hl)
0240   024B B7          	or		a
0241   024C 28 11       	jr		z, .p2
0242   024E FE 2F       	cp		'/'
0243   0250 CA 60 02    	jp		z, .p3
0244   0253 FE 20       	cp		' '
0245   0255 CA 5F 02    	jp		z, .p2
0246   0258 FE 0D       	cp		13
0247   025A 28 03       	jr		z, .p2
0248   025C 12          	ld		(de),a
0249   025D 13          	inc		de
0250   025E 0C          	inc		c
0251   025F             .p2: 
0252   025F 2B          	dec		hl
0253   0260             .p3: 
0254   0260 23          	inc		hl
0255   0261 23          	inc		hl
0256   0262 10 E6       	djnz	.loop0
0257   0264 41          	ld		b, c
0258   0265 79          	ld		a, c
0259   0266 B7          	or		a
0260   0267 C0          	ret	nz
0261   0268 06 01       	ld		b, 1
0262   026A C9          	ret
0263   026B             
0264   026B             ; --------------------------------------
0265   026B             ; checkOptions
0266   026B             ; OPTIONS :
0267   026B             ;			0 - erase flash only	/e
0268   026B             ;			1 - show list of chips	/l
0269   026B             ;
0270   026B             ; ---------------------------------------
0271   026B             checkOptions: 
0272   026B C5          	push	bc
0273   026C AF          	xor		a
0274   026D 32 F6 09    	ld		(options), a
0275   0270 3A 80 00    	ld		a, (CMD_LENGTH)
0276   0273 47          	ld		b, a
0277   0274 21 82 00    	ld		hl, CMD_LINE
0278   0277             .loop0: 
0279   0277 7E          	ld		a, (hl)
0280   0278 FE 2F       	cp		'/'
0281   027A CC 81 02    	call	z, .ch1
0282   027D             .p1: 
0283   027D 23          	inc		hl
0284   027E 10 F7       	djnz	.loop0
0285   0280 C1          	pop		bc
0286   0281             
0287   0281             .ch1: 
0288   0281 23          	inc		hl
0289   0282 7E          	ld		a, (hl)
0290   0283 F6 20       	or		000100000b
0291   0285 11 C8 06    	ld		de, strHelp
0292   0288 FE 3F       	cp		'?'
0293   028A CA 0A 05    	jp		z, printErro
0294   028D FE 68       	cp		'h'
0295   028F CA 0A 05    	jp		z, printErro
0296   0292             
0297   0292 0E 01       	ld		c, 1
0298   0294 FE 65       	cp		'e'
0299   0296 28 07       	jr		z, .achado
0300   0298 CB 21       	sla		c
0301   029A FE 6C       	cp		'l'
0302   029C 28 01       	jr		z, .achado
0303   029E C9          	ret
0304   029F             .achado: 
0305   029F 3A F6 09    	ld		a, (options)
0306   02A2 B1          	or		c
0307   02A3 32 F6 09    	ld		(options), a
0308   02A6 C9          	ret
0309   02A7             
0310   02A7             ; ---------------------
0311   02A7             ; CHECK FILE
0312   02A7             ; CHECK IF FILE EXIST
0313   02A7             ; ---------------------
0314   02A7             checkFile: 
0315   02A7 11 62 08    	ld		de, strAbrirArq
0316   02AA CD 3E 05    	call	print						; Open text
0317   02AD 3A F4 09    	ld		a, (dos)
0318   02B0 FE 02       	cp		2
0319   02B2 D2 C4 02    	jp		nc, .dos2					; DOS2 mode
0320   02B5             
0321   02B5 CD 43 05    	call	makeFCB						; DOS1. Make FCB and Open command.
0322   02B8 21 49 0A    	ld		hl, fileNameDOS1
0323   02BB CD 51 05    	call	buildFCB
0324   02BE CD 5A 05    	call	open						; Open. If file doesn't exist then error and exit.
0325   02C1 C3 FB 02    	jp		.p1
0326   02C4             
0327   02C4             .dos2: 									; DOS2 Open
0328   02C4 11 09 0A    	ld		de, fileNameDOS2
0329   02C7 AF          	xor		a
0330   02C8 06 00       	ld		b, 0
0331   02CA 0E 43       	ld		c, _OPEN					; Open file DOS2
0332   02CC CD 02 05    	call	callBdos
0333   02CF 11 1A 08    	ld		de, strErroAbrirArq
0334   02D2 C2 0A 05    	jp		nz, printErro				; if Z = 0 then file not found. Error and Exit
0335   02D5 78          	ld		a, b
0336   02D6 32 08 0A    	ld		(fileHandle), a				; Save FILE HANDLE
0337   02D9 C5          	push	bc							; For check size in DOS 2, use SEEK Command.
0338   02DA 3E 02       	ld		a, SEEK_END
0339   02DC 11 00 00    	ld		de, 0
0340   02DF 21 00 00    	ld		hl, 0
0341   02E2 0E 4A       	ld		c, _SEEK					; Seek
0342   02E4 CD 02 05    	call	callBdos
0343   02E7 22 68 0A    	ld		(sizefile), hl
0344   02EA ED 53 6A 0A 	ld		(sizefile+2), de
0345   02EE C1          	pop		bc
0346   02EF AF          	xor		a							; And Now Return Seek to POS 0 (SEEK_SET)
0347   02F0 11 00 00    	ld		de, 0
0348   02F3 21 00 00    	ld		hl, 0
0349   02F6 0E 4A       	ld		c, _SEEK
0350   02F8 CD 02 05    	call	callBdos
0351   02FB             .p1: 
0352   02FB 11 3F 08    	ld		de, strTamanhoErrado		; Test filesize. 128K = 00 00 02
0353   02FE 3A 68 0A    	ld		a, (sizefile)
0354   0301 B7          	or		a
0355   0302 C2 0A 05    	jp		nz, printErro
0356   0305 3A 69 0A    	ld		a, (sizefile+1)
0357   0308 B7          	or		a
0358   0309 C2 0A 05    	jp		nz, printErro
0359   030C 3A 6A 0A    	ld		a, (sizefile+2)
0360   030F FE 02       	cp		2
0361   0311 C2 0A 05    	jp		nz, printErro
0362   0314 C9          	ret
0363   0315             
0364   0315             ; *** PROGRAM ROUTINES ***
0365   0315             
0366   0315             ; ----------------------------
0367   0315             ; LOADFILE
0368   0315             ; Load File into Flash
0369   0315             ; Load ALL FILE into Flash ROM
0370   0315             ; ----------------------------
0371   0315             loadFile: 
0372   0315 11 96 08    	ld		de, strGravando
0373   0318 CD 3E 05    	call	print						; Show Write Text
0374   031B 06 08       	ld		b, 8						; 8 blocos de 16K = 128K
0375   031D             .loop: 
0376   031D C5          	push	bc
0377   031E CD 79 03    	call	fillPage					; fill page 2 (read buffer) with $FF
0378   0321 CD 4F 03    	call	load16K						; and load one 16 K page to buffer
0379   0324 C1          	pop		bc
0380   0325 C5          	push	bc
0381   0326 CD 4A 04    	call	writeFlash					; now write this 16 K to FLASH
0382   0329 FB          	ei
0383   032A 11 A3 08    	ld		de, strErroAoGravarFlash
0384   032D C2 0A 05    	jp		nz, printErro				; oops! Error writing bytes. Show Error and exit.
0385   0330             
0386   0330 11 94 08    	ld		de, strPonto
0387   0333 CD 3E 05    	call	print						; show '*' for 16 K page loaded
0388   0336 C1          	pop		bc
0389   0337 3A F8 09    	ld		a, (actualpage)
0390   033A 3C          	inc		a
0391   033B 32 F8 09    	ld		(actualpage), a				; and inc page to next loop
0392   033E 10 DD       	djnz	.loop						; next loop
0393   0340             
0394   0340 CD A4 05    	call	closeFile					; end for load. close File.
0395   0343 11 C5 06    	ld		de, strCrLf
0396   0346 CD 3E 05    	call	print
0397   0349 11 C9 08    	ld		de, strUpdateCompleto		; and print Success Text.
0398   034C C3 3E 05    	jp		print
0399   034F             
0400   034F             
0401   034F             ; ------------------
0402   034F             ; LOAD16K
0403   034F             ; Load 16K
0404   034F             ; to page 2
0405   034F             ; from file open
0406   034F             ; ------------------
0407   034F             load16K: 
0408   034F             	; this code load 16 KB from file
0409   034F             	; to buffer (page 2 $8000 - $BFFF)
0410   034F             
0411   034F 3A 43 F3    	ld		a, (RAMAD2)
0412   0352 26 80       	ld		h, $80
0413   0354 CD 24 00    	call	ENASLT						; mem in page 2
0414   0357 FB          	ei
0415   0358 11 00 80    	ld		de, $8000					; buffer = $8000
0416   035B 21 00 40    	ld		hl, $4000					; length = $4000 (16K)
0417   035E 3A F4 09    	ld		a, (dos)
0418   0361 FE 02       	cp		2
0419   0363 30 0B       	jr		nc, .dos2					; if DOS 2 make <> load
0420   0365 E5          	push	hl							; DOS 1 LOAD.
0421   0366 CD 97 05    	call	setDTA						; set DTA
0422   0369 E1          	pop		hl
0423   036A CD BC 05    	call	readMax						; and read 16 KB or max if file < 16K or file size
0424   036D C3 9C 05    	jp		readFile					; is not mult. of 16. And READ.
0425   0370             .dos2: 									; DOS 2 LOAD
0426   0370 3A 08 0A    	ld		a, (fileHandle)
0427   0373 47          	ld		b, a
0428   0374 0E 48       	ld		c, _READ					; DOS 2 COMMAND Read
0429   0376 C3 FA 04    	jp		callBdosCE
0430   0379             
0431   0379             ; --------------------
0432   0379             ; FILL PAGE
0433   0379             ; Fill page 2 with FFH
0434   0379             ; ---------------------
0435   0379             fillPage: 
0436   0379 21 00 80    	ld		hl, $8000
0437   037C 11 01 80    	ld		de, $8001
0438   037F 01 FF 3F    	ld		bc, $3FFF
0439   0382 36 FF       	ld		(hl), $FF
0440   0384 ED B0       	ldir								; fill
0441   0386 C9          	ret
0442   0387             
0443   0387             ; -----------------
0444   0387             ; FILLNAME
0445   0387             ; Search params for
0446   0387             ; extract fileName
0447   0387             ; -----------------
0448   0387             fillName: 
0449   0387 21 48 0A    	ld		hl, fileNameDOS2 + 63
0450   038A 06 40       	ld		b, 64						; max params. End to init loop
0451   038C             .loop: 
0452   038C 7E          	ld		a,(hl)
0453   038D B7          	or		a
0454   038E 28 08       	jr		z, .p1						; 0 dec
0455   0390 FE 3A       	cp		':'                     	; end
0456   0392 28 07       	jr		z, .p2
0457   0394 FE 5C       	cp		'\\'						; params
0458   0396 28 03       	jr		z, .p2
0459   0398             .p1: 
0460   0398 2B          	dec		hl
0461   0399 10 F1       	djnz	.loop
0462   039B             .p2: 
0463   039B 23          	inc		hl
0464   039C 11 70 08    	ld		de, strAbrirArq.nomearq		; loop for fill fileNameShow
0465   039F             .loop2: 
0466   039F 7E          	ld		a, (hl)
0467   03A0 B7          	or		a
0468   03A1 C8          	ret	z
0469   03A2 12          	ld		(de),a
0470   03A3 23          	inc		hl
0471   03A4 13          	inc		de
0472   03A5 18 F8       	jr		.loop2
0473   03A7             
0474   03A7             ; ----------------------
0475   03A7             ; DELAY
0476   03A7             ; Flash operation delay
0477   03A7             ; ----------------------
0478   03A7             delay: 
0479   03A7 E5          	push	hl
0480   03A8 D5          	push	de
0481   03A9 C5          	push	bc							; this delay is for erasing operations
0482   03AA 3A 42 F3    	ld		a, (RAMAD1)
0483   03AD 26 40       	ld		h, $40
0484   03AF CD 24 00    	call	ENASLT						; set mem to page 1
0485   03B2 3A 02 0A    	ld		a, (erasedelay)				; loop times from delay.
0486   03B5 47          	ld		b, a
0487   03B6             .loop: 
0488   03B6 C5          	push	bc
0489   03B7 FB          	ei
0490   03B8 76          	halt
0491   03B9 F3          	di
0492   03BA C1          	pop		bc
0493   03BB 10 F9       	djnz	.loop
0494   03BD 3A FA 09    	ld		a, (flashslt)
0495   03C0 26 40       	ld		h, $40
0496   03C2 CD 24 00    	call	ENASLT						; return flash to page 1 (DOS1 Compatibility)
0497   03C5 FB          	ei
0498   03C6 C1          	pop		bc
0499   03C7 D1          	pop		de
0500   03C8 E1          	pop		hl
0501   03C9 C9          	ret
0502   03CA             
0503   03CA             ; -------------------------------------------------------
0504   03CA             ; SIGSLOT
0505   03CA             ; Returns in A the next slot every time it is called.
0506   03CA             ; For initializing purposes, thisslt has to be #FF.
0507   03CA             ; If no more slots, it returns A=#FF.
0508   03CA             ; this code is programmed by Nestor Soriano aka Konamiman
0509   03CA             ; --------------------------------------------------------
0510   03CA             sigslot: 
0511   03CA 3A F9 09    	ld		a, (thisslt)				; Returns the next slot, starting by
0512   03CD FE FF       	cp		$FF							; slot 0. Returns #FF when there are not more slots
0513   03CF 20 09       	jr		nz, .p1						; Modifies AF, BC, HL.
0514   03D1 3A C1 FC    	ld		a, (EXPTBL)
0515   03D4 E6 80       	and		%10000000
0516   03D6 32 F9 09    	ld		(thisslt), a
0517   03D9 C9          	ret
0518   03DA             .p1: 
0519   03DA 3A F9 09    	ld		a, (thisslt)
0520   03DD FE 8F       	cp		%10001111
0521   03DF 28 28       	jr		z, .nomaslt
0522   03E1 FE 03       	cp		%00000011
0523   03E3 28 24       	jr		z, .nomaslt
0524   03E5 CB 7F       	bit		7, a
0525   03E7 20 12       	jr		nz, .sltexp
0526   03E9             .p2: 
0527   03E9 E6 03       	and		%00000011
0528   03EB 3C          	inc		a
0529   03EC 4F          	ld		c, a
0530   03ED 06 00       	ld		b, 0
0531   03EF 21 C1 FC    	ld		hl, EXPTBL
0532   03F2 09          	add		hl, bc
0533   03F3 7E          	ld		a, (hl)
0534   03F4 E6 80       	and		%10000000
0535   03F6 B1          	or		c
0536   03F7 32 F9 09    	ld		(thisslt), a
0537   03FA C9          	ret
0538   03FB             .sltexp: 
0539   03FB 4F          	ld		c, a
0540   03FC E6 0C       	and		%00001100
0541   03FE FE 0C       	cp		%00001100
0542   0400 79          	ld		a, c
0543   0401 28 E6       	jr		z, .p2
0544   0403 C6 04       	add		a, %00000100
0545   0405 32 F9 09    	ld		(thisslt), a
0546   0408 C9          	ret
0547   0409             .nomaslt: 
0548   0409 3E FF       	ld		a, $FF
0549   040B C9          	ret
0550   040C             
0551   040C             ; *** FLASH ROUTINES ***
0552   040C             
0553   040C             ; ----------------------
0554   040C             ; flashSendCommand1
0555   040C             ; send command in A to 
0556   040C             ; flash mapped in page 1
0557   040C             ; Preserve flags
0558   040C             ; ----------------------
0559   040C             flashSendCommand1: 
0560   040C E5          	push	hl
0561   040D F5          	push	af
0562   040E 3E 81       	ld		a, $81
0563   0410 D3 5F       	out		(IOFW), a					; Ativa modo de gravacao e seleciona pagina 1 da flash
0564   0412 21 55 55    	ld		hl, $5555					; Escreve no endereco absoluto da flash $5555
0565   0415 36 AA       	ld		(hl), $AA
0566   0417 3E 80       	ld		a, $80
0567   0419 D3 5F       	out		(IOFW), a					; Mantem modo de gravacao e seleciona pagina 0 da flash
0568   041B 21 AA 6A    	ld		hl, $6AAA					; Escreve no endereco absoluto da flash $2AAA
0569   041E 36 55       	ld		(hl), $55
0570   0420 3E 81       	ld		a, $81
0571   0422 D3 5F       	out		(IOFW), a					; Mantem modo de gravacao e seleciona pagina 1 da flash
0572   0424 21 55 55    	ld		hl, $5555					; Escreve no endereco absoluto da flash $5555
0573   0427 F1          	pop		af
0574   0428 77          	ld		(hl), a						; Envia comando
0575   0429 E1          	pop		hl
0576   042A C9          	ret
0577   042B             
0578   042B             ; ----------------------
0579   042B             ; flashSendCommand2
0580   042B             ; send command in A to 
0581   042B             ; flash mapped in page 2
0582   042B             ; Preserve flags
0583   042B             ; ----------------------
0584   042B             flashSendCommand2: 
0585   042B E5          	push	hl
0586   042C F5          	push	af
0587   042D 3E 81       	ld		a, $81
0588   042F D3 5F       	out		(IOFW), a					; Ativa modo de gravacao e seleciona pagina 1 da flash
0589   0431 21 55 95    	ld		hl, $9555					; Escreve no endereco absoluto da flash $5555
0590   0434 36 AA       	ld		(hl), $AA
0591   0436 3E 80       	ld		a, $80
0592   0438 D3 5F       	out		(IOFW), a					; Mantem modo de gravacao e seleciona pagina 0 da flash
0593   043A 21 AA AA    	ld		hl, $AAAA					; Escreve no endereco absoluto da flash $2AAA
0594   043D 36 55       	ld		(hl), $55
0595   043F 3E 81       	ld		a, $81
0596   0441 D3 5F       	out		(IOFW), a					; Mantem modo de gravacao e seleciona pagina 1 da flash
0597   0443 21 55 95    	ld		hl, $9555					; Escreve no endereco absoluto da flash $5555
0598   0446 F1          	pop		af
0599   0447 77          	ld		(hl), a						; Envia comando
0600   0448 E1          	pop		hl
0601   0449 C9          	ret
0602   044A             
0603   044A             
0604   044A             ; ----------------------
0605   044A             ; WRITEFLASH
0606   044A             ; Write 16 KB into Flash
0607   044A             ; page 1 : Flash
0608   044A             ; page 2 : Buffer
0609   044A             ; NZ = Error
0610   044A             ; ----------------------
0611   044A             writeFlash: 
0612   044A 3A 43 F3    	ld		a, (RAMAD2)
0613   044D 26 80       	ld		h, $80
0614   044F CD 24 00    	call	ENASLT						; mem to page 2 (DOS1)
0615   0452             
0616   0452 3A FA 09    	ld		a, (flashslt)
0617   0455 26 40       	ld		h, $40
0618   0457 CD 24 00    	call	ENASLT						; flash to page 1
0619   045A             
0620   045A 21 00 80    	ld		hl, $8000					; buffer pointer
0621   045D 11 00 40    	ld		de, $4000					; flash pointer
0622   0460 42          	ld		b, d
0623   0461 4B          	ld		c, e
0624   0462 F3          	di
0625   0463             .loop: 
0626   0463 3E A0       	ld		a, $A0						; Modo de gravacao de dados
0627   0465 CD 0C 04    	call	flashSendCommand1
0628   0468 3A F8 09    	ld		a, (actualpage)
0629   046B F6 80       	or		$80
0630   046D D3 5F       	out		(IOFW), a					; select 16K page in Flash
0631   046F CD 8A 04    	call	.gravaByte					; program byte
0632   0472 20 08       	jr		nz, .erro					; ERROR. Z = 0
0633   0474 23          	inc		hl							; Ok. Next byte.
0634   0475 13          	inc		de
0635   0476 0B          	dec		bc
0636   0477 78          	ld		a, b
0637   0478 B1          	or		c
0638   0479 C2 63 04    	jp		nz, .loop					; All 16 KB programmed? Return for making next block.
0639   047C             .erro: 
0640   047C F5          	push	af
0641   047D AF          	xor		a
0642   047E D3 5F       	out		(IOFW), a					; Desliga modo gravacao da Flash
0643   0480 3A 42 F3    	ld		a, (RAMAD1)
0644   0483 26 40       	ld		h, $40
0645   0485 CD 24 00    	call	ENASLT						; Mem to PAGE 1 (DOS 1 Compatibility)
0646   0488 F1          	pop		af
0647   0489 C9          	ret
0648   048A             
0649   048A             ; program byte and check 30 times
0650   048A             .gravaByte: 
0651   048A E5          	push	hl
0652   048B D5          	push	de
0653   048C C5          	push	bc
0654   048D 0E 1E       	ld		c, 30
0655   048F             .loop2: 									; write byte loop
0656   048F 7E          	ld		a, (hl)
0657   0490 12          	ld		(de), a
0658   0491             .loop3: 
0659   0491 00          	nop									; little delay
0660   0492 00          	nop
0661   0493 0D          	dec		c
0662   0494 1A          	ld		a, (de)
0663   0495 AE          	xor		(hl)
0664   0496 28 05       	jr		z, .fim						; ok programmed
0665   0498 79          	ld		a, c
0666   0499 B7          	or		a
0667   049A 20 F5       	jr		nz, .loop3
0668   049C 3C          	inc		a							; oops! Error
0669   049D             .fim: 
0670   049D C1          	pop		bc
0671   049E D1          	pop		de
0672   049F E1          	pop		hl
0673   04A0 C9          	ret
0674   04A1             
0675   04A1             ; -----------------------
0676   04A1             ; ERASEFLASH
0677   04A1             ; Sector Erase command
0678   04A1             ; or CHIP Erase Command
0679   04A1             ; -----------------------
0680   04A1             eraseFlash: 
0681   04A1 11 83 08    	ld		de, strApagarFlash
0682   04A4 CD 3E 05    	call	print						; Erase Text Show.
0683   04A7 3A FA 09    	ld		a, (flashslt)
0684   04AA 26 40       	ld		h, $40
0685   04AC CD 24 00    	call	ENASLT						; set flash in page 1
0686   04AF F3          	di
0687   04B0             ;	xor		a
0688   04B0             ;	ld		(erasedelay), a				; delay de 256 ciclos
0689   04B0 3E 80       	ld		a, $80						; Apaga chip
0690   04B2 CD 0C 04    	call	flashSendCommand1
0691   04B5 3E 10       	ld		a, $10
0692   04B7 CD 0C 04    	call	flashSendCommand1
0693   04BA 21 00 40    	ld		hl, $4000
0694   04BD 7E          	ld		a, (hl)
0695   04BE 32 03 0A    	ld		(togglebit), a
0696   04C1             .loop: 									; testa fim do erase por Toggle Bit
0697   04C1 3A 03 0A    	ld		a, (togglebit)
0698   04C4 BE          	cp		(hl)
0699   04C5 7E          	ld		a, (hl)
0700   04C6 32 03 0A    	ld		(togglebit), a
0701   04C9 20 F6       	jr		nz, .loop
0702   04CB             ;	xor		a
0703   04CB             ;	out		(IOFW), a					; Desliga modo gravacao da Flash
0704   04CB             ;	call	delay						; make programmed delay.
0705   04CB             ;	call	delay						; make programmed delay.
0706   04CB             ;	di
0707   04CB 3E F0       	ld		a, $F0						; end command. Reset Command.
0708   04CD CD 0C 04    	call	flashSendCommand1
0709   04D0 AF          	xor		a
0710   04D1 D3 5F       	out		(IOFW), a					; Desliga modo gravacao da Flash
0711   04D3 FB          	ei
0712   04D4 3A 42 F3    	ld		a, (RAMAD1)
0713   04D7 26 40       	ld		h, $40
0714   04D9 CD 24 00    	call	ENASLT						; set mem to page 1
0715   04DC 11 FE 07    	ld		de, strOk
0716   04DF CD 3E 05    	call	print
0717   04E2 3A F6 09    	ld		a, (options)
0718   04E5 CB 47       	bit		0, a						; check if /e command.
0719   04E7 C8          	ret	z								; No. Return to Main program
0720   04E8 C3 0F 05    	jp		exitok						; Yes. Exit.
0721   04EB             
0722   04EB             
0723   04EB             ; *** GENERIC SYSTEM ROUTINES ***
0724   04EB             
0725   04EB             ; -------------
0726   04EB             ; CURSOR ON OFF
0727   04EB             ; -------------
0728   04EB             cursorOn: 
0729   04EB 3E 01       	ld		a, 1
0730   04ED             
0731   04ED             cursorSet: 
0732   04ED 32 A9 FC    	ld		(CSRSW), a
0733   04F0 C9          	ret
0734   04F1             
0735   04F1             cursorOff: 
0736   04F1 AF          	xor		a
0737   04F2 18 F9       	jr		cursorSet
0738   04F4             
0739   04F4             
0740   04F4             ; ----------------
0741   04F4             ; cmpHLcomDE
0742   04F4             ; Compares HL and DE
0743   04F4             ; BIOS RST 020H clone
0744   04F4             ; -----------------
0745   04F4             cmpHLcomDE: 
0746   04F4 7C          	ld		a, h
0747   04F5 92          	sub		d
0748   04F6 C0          	ret		nz
0749   04F7 7D          	ld		a, l
0750   04F8 93          	sub		e
0751   04F9 C9          	ret
0752   04FA             
0753   04FA             ; ---------------
0754   04FA             ; BDOSCE
0755   04FA             ; bdos with error
0756   04FA             ; Call to BDOS and
0757   04FA             ; check error
0758   04FA             ; ----------------
0759   04FA             callBdosCE: 
0760   04FA CD 05 00    	call	BDOS
0761   04FD B7          	or		a
0762   04FE C2 07 05    	jp		nz, error
0763   0501 C9          	ret
0764   0502             
0765   0502             ; -----------------
0766   0502             ; BDOS
0767   0502             ; bdos without error
0768   0502             ; ------------------
0769   0502             callBdos: 
0770   0502 CD 05 00    	call	BDOS
0771   0505 B7          	or		a
0772   0506 C9          	ret
0773   0507             
0774   0507             ; -----------------------------------------------
0775   0507             ; ERROR
0776   0507             ; print error
0777   0507             ; call printErro and set DE pointer to error text
0778   0507             ; -----------------------------------------------
0779   0507             error: 
0780   0507 11 05 08    	ld		de, strErro
0781   050A             printErro: 
0782   050A 0E 09       	ld		c, _STROUT
0783   050C CD 02 05    	call	callBdos
0784   050F             
0785   050F             ; ---------------
0786   050F             ; EXITOK
0787   050F             ; Exit OK
0788   050F             ; ---------------
0789   050F             exitok: 
0790   050F CD A4 05    	call	closeFile					; close file (open or not)
0791   0512 3A 42 F3    	ld		a, (RAMAD1)
0792   0515 26 40       	ld		h, $40
0793   0517 CD 24 00    	call	ENASLT						; set mem to page 1
0794   051A 3A 43 F3    	ld		a, (RAMAD2)
0795   051D 26 80       	ld		h, $80
0796   051F CD 24 00    	call	ENASLT						; set mem to page 2
0797   0522 3A F5 09    	ld		a, (system)
0798   0525 FE 03       	cp		3							; Turbo R?
0799   0527 38 06       	jr		c, exit						; No. Go To Exit
0800   0529 3A F2 09    	ld		a, (savecpu)				; Yes. Restore CPU Mode
0801   052C CD FA 01    	call	systemSetCPU
0802   052F             
0803   052F             ; ---------------
0804   052F             ; EXIT
0805   052F             ; program exit
0806   052F             ; ---------------
0807   052F             exit: 
0808   052F 3A F3 09    	ld		a,(savecursor)				; Restore Cursor Value
0809   0532 CD ED 04    	call	cursorSet
0810   0535 ED 7B F0 09 	ld		sp, (savesp)				; And Restore SP
0811   0539 0E 00       	ld		c, _TERM0					; Program Terminate BDOS Command.
0812   053B C3 02 05    	jp		callBdos					; Go and Exit. WOW!
0813   053E             
0814   053E             ; *** BDOS ROUTINES ***
0815   053E             
0816   053E             ; -------------------
0817   053E             ; PRINT
0818   053E             ; DE : Pointer to Text
0819   053E             ; --------------------
0820   053E             print: 
0821   053E 0E 09       	ld		c, _STROUT
0822   0540 C3 02 05    	jp		callBdos
0823   0543             
0824   0543             ; ----------------
0825   0543             ; makeFCB
0826   0543             ; Prepare NEW FCB
0827   0543             ; ---------------
0828   0543             makeFCB: 
0829   0543 21 58 0A    	ld		hl, FCB
0830   0546 11 59 0A    	ld		de, FCB+1
0831   0549 36 00       	ld		(hl), 0
0832   054B 01 25 00    	ld		bc, 37
0833   054E ED B0       	ldir
0834   0550 C9          	ret
0835   0551             
0836   0551             ; -------------
0837   0551             ; buildFCB
0838   0551             ; HL = Pointer to namefile string
0839   0551             ; ----------------
0840   0551             buildFCB: 
0841   0551 11 59 0A    	ld		de, fileName
0842   0554 01 0B 00    	ld		bc, 11
0843   0557 ED B0       	ldir
0844   0559 C9          	ret
0845   055A             
0846   055A             ; ---------------
0847   055A             ; OPEN FCB FILE
0848   055A             ; ---------------
0849   055A             open: 
0850   055A 11 58 0A    	ld		de, FCB
0851   055D 0E 0F       	ld		c, _FOPEN
0852   055F CD 02 05    	call	callBdos
0853   0562 11 1A 08    	ld		de, strErroAbrirArq
0854   0565 C2 0A 05    	jp		nz, printErro
0855   0568 DD 21 58 0A 	ld		ix, FCB
0856   056C 3E 01       	ld		a, 1
0857   056E DD 77 0E    	ld		(ix+14), a
0858   0571 AF          	xor		a
0859   0572 DD 77 0F    	ld		(ix+15), a
0860   0575 DD 36 21 00 	ld		(ix+33), 0
0861   0579 DD 36 22 00 	ld		(ix+34), 0
0862   057D DD 36 23 00 	ld		(ix+35), 0
0863   0581 DD 36 24 00 	ld		(ix+36), 0
0864   0585 C9          	ret
0865   0586             
0866   0586             ; --------------
0867   0586             ; SEEK
0868   0586             ; DEHL = Pointer
0869   0586             ; --------------
0870   0586             seek: 
0871   0586 DD 21 58 0A 	ld		ix, FCB
0872   058A DD 75 21    	ld		(ix+33), l
0873   058D DD 74 22    	ld		(ix+34), h
0874   0590 DD 73 23    	ld		(ix+35), e
0875   0593 DD 72 24    	ld		(ix+36), d
0876   0596 C9          	ret
0877   0597             
0878   0597             ; ------------
0879   0597             ; setDTA
0880   0597             ; DE = Buffer
0881   0597             ; ------------
0882   0597             setDTA: 
0883   0597 0E 1A       	ld		c, _SETDTA
0884   0599 C3 02 05    	jp		callBdos
0885   059C             
0886   059C             ; -------------------------------------------------------
0887   059C             ; READ
0888   059C             ; HL Bytes to read from opened FCB, with the pointer ready
0889   059C             ; -------------------------------------------------------
0890   059C             readFile: 
0891   059C 11 58 0A    	ld		de, FCB
0892   059F 0E 27       	ld		c, _RDBLK
0893   05A1 C3 FA 04    	jp		callBdosCE
0894   05A4             
0895   05A4             ; ----------------
0896   05A4             ; closeFile
0897   05A4             ; close FCB FILE
0898   05A4             ; close File. Check DOS variable for DOS2 and DOS1 close
0899   05A4             ; ----------------
0900   05A4             closeFile: 
0901   05A4 3A F4 09    	ld		a, (dos)
0902   05A7 FE 02       	cp		2
0903   05A9 30 08       	jr		nc, .dos2
0904   05AB 11 58 0A    	ld		de, FCB
0905   05AE 0E 10       	ld		c, _FCLOSE
0906   05B0 C3 02 05    	jp		callBdos
0907   05B3             .dos2: 
0908   05B3 3A 08 0A    	ld		a, (fileHandle)
0909   05B6 47          	ld		b, a
0910   05B7 0E 45       	ld		c, _CLOSE
0911   05B9 C3 02 05    	jp		callBdos
0912   05BC             
0913   05BC             ; -------------------------
0914   05BC             ; READ MAX
0915   05BC             ; HL : Size to read
0916   05BC             ; Returns HL max size
0917   05BC              ; this code is for DOS1 Compatibility
0918   05BC              ; In DOS2 if HL parameter (Read Size) > Size File or Bytes to read
0919   05BC              ; Do not Return ERROR
0920   05BC              ; But DOS1 RETURN ERROR
0921   05BC              ; The Load16K Code USES HL = 16384 bytes ALWAYS.
0922   05BC             ; -------------------------
0923   05BC             readMax: 
0924   05BC F5          	push	af
0925   05BD D5          	push	de
0926   05BE E5          	push	hl
0927   05BF AF          	xor		a
0928   05C0 2A 6A 0A    	ld		hl, (sizefile+2)
0929   05C3 ED 5B 7B 0A 	ld		de, (sizeread+2)
0930   05C7 ED 52       	sbc		hl, de
0931   05C9 22 06 0A    	ld		(sizefiletmp+2), hl
0932   05CC 2A 68 0A    	ld		hl, (sizefile)
0933   05CF ED 5B 79 0A 	ld		de, (sizeread)
0934   05D3 ED 52       	sbc		hl, de
0935   05D5 22 04 0A    	ld		(sizefiletmp), hl
0936   05D8 E1          	pop		hl
0937   05D9 E5          	push	hl
0938   05DA ED 5B 04 0A 	ld		de, (sizefiletmp)
0939   05DE CD F4 04    	call	cmpHLcomDE
0940   05E1 30 04       	jr		nc, .readmax0
0941   05E3 E1          	pop		hl
0942   05E4             .readmaxend: 
0943   05E4 D1          	pop		de
0944   05E5 F1          	pop		af
0945   05E6 C9          	ret
0946   05E7             .readmax0: 
0947   05E7 ED 5B 06 0A 	ld		de, (sizefiletmp+2)
0948   05EB 21 00 00    	ld		hl, 0
0949   05EE CD F4 04    	call	cmpHLcomDE
0950   05F1 E1          	pop		hl
0951   05F2 20 F0       	jr		nz, .readmaxend
0952   05F4             .readmax1: 
0953   05F4 2A 04 0A    	ld		hl, (sizefiletmp)
0954   05F7 18 EB       	jr		.readmaxend
0955   05F9             
0956   05F9             ; ----------------------
0957   05F9             ; ShowList
0958   05F9             ; Exibe a lista de flashs
0959   05F9             ; suportadas
0960   05F9             ; ----------------------
0961   05F9             showList: 
0962   05F9 11 EB 08    	ld		de, strListaCab
0963   05FC CD 3E 05    	call	print
0964   05FF 21 2E 09    	ld		hl, tblFlash				; HL aponta para inicio da tabela
0965   0602             .loop: 
0966   0602 7E          	ld		a, (hl)
0967   0603 FE 00       	cp		0							; acabou a tabela?
0968   0605 CA 2F 05    	jp		z, exit
0969   0608 32 FB 09    	ld		(flashIdMan), a				; salva ID do fabricante
0970   060B 23          	inc		hl
0971   060C 7E          	ld		a, (hl)						; pega ID do produto
0972   060D 32 FC 09    	ld		(flashIdProd), a			; e salva
0973   0610 23          	inc		hl
0974   0611 5E 23 56 2B 	ld		de, (hl)					; vamos pegar a string do fabricante
0975   0615 ED 53 FE 09 	ld		(flashManPoint), de			; e salvar
0976   0619 23          	inc		hl
0977   061A 23          	inc		hl
0978   061B 5E 23 56 2B 	ld		de, (hl)					; vamos pegar a string do produto
0979   061F ED 53 00 0A 	ld		(flashProdPoint), de		; e salvar
0980   0623 23          	inc		hl
0981   0624 23          	inc		hl
0982   0625 7E          	ld		a, (hl)						; vamos pegar o algoritmo
0983   0626 32 FD 09    	ld		(flashAlg), a				; e salvar
0984   0629 23          	inc		hl
0985   062A E5          	push	hl
0986   062B ED 5B FE 09 	ld		de, (flashManPoint)
0987   062F CD 3E 05    	call	print
0988   0632 ED 5B 00 0A 	ld		de, (flashProdPoint)
0989   0636 CD 3E 05    	call	print
0990   0639 11 C5 06    	ld		de, strCrLf
0991   063C CD 3E 05    	call	print
0992   063F E1          	pop		hl
0993   0640 18 C0       	jr		.loop
0994   0642 C9          	ret
0995   0643             
0996   0643             ; ----------------------
0997   0643             ; FlashIdent
0998   0643             ; Identifies Flash
0999   0643             ; ----------------------
1000   0643             flashIdent: 
1001   0643 E5          	push	hl
1002   0644 C5          	push	bc
1003   0645 D5          	push	de
1004   0646 21 2E 09    	ld		hl, tblFlash				; HL aponta para inicio da tabela
1005   0649 3A FB 09    	ld		a, (flashIdMan)
1006   064C 47          	ld		b, a						; B contem ID do fabricante
1007   064D 16 00       	ld		d, 0						; DE eh usado para incrementar HL para proxima entrada da tabela
1008   064F             .loop: 
1009   064F 7E          	ld		a, (hl)
1010   0650 FE 00       	cp		0							; acabou a tabela?
1011   0652 28 2D       	jr		z, .naoId					; entao nao identificamos
1012   0654 B8          	cp		b							; comparar ID do fabricante
1013   0655 28 05       	jr		z, .idp						; bateu, vamos verificar o ID do produto
1014   0657 1E 07       	ld		e, 7
1015   0659 19          	add		hl, de						; nao encontramos nessa entrada, vamos para a proxima
1016   065A 18 F3       	jr		.loop
1017   065C             .idp: 
1018   065C 23          	inc		hl							; vamos comparar o ID do produto
1019   065D 3A FC 09    	ld		a, (flashIdProd)
1020   0660 BE          	cp		(hl)						; ID do produto bate?
1021   0661 28 05       	jr		z, .ok						; beleza, identificamos a flash
1022   0663 1E 06       	ld		e, 6
1023   0665 19          	add		hl, de						; ID do produto nao bateu, vamos para a proxima entrada
1024   0666 18 E7       	jr		.loop
1025   0668             .ok: 
1026   0668 23          	inc		hl
1027   0669 5E 23 56 2B 	ld		de, (hl)					; vamos pegar a string do fabricante
1028   066D ED 53 FE 09 	ld		(flashManPoint), de			; e salvar
1029   0671 23          	inc		hl
1030   0672 23          	inc		hl
1031   0673 5E 23 56 2B 	ld		de, (hl)					; vamos pegar a string do produto
1032   0677 ED 53 00 0A 	ld		(flashProdPoint), de		; e salvar
1033   067B 23          	inc		hl
1034   067C 23          	inc		hl
1035   067D 7E          	ld		a, (hl)						; vamos pegar o algoritmo
1036   067E 32 FD 09    	ld		(flashAlg), a				; e salvar
1037   0681             .naoId: 
1038   0681 D1          	pop		de
1039   0682 C1          	pop		bc
1040   0683 E1          	pop		hl
1041   0684 C9          	ret
1042   0685             
1043   0685             ; *** TEXTS ***
1044   0685             
1045   0685             strTitulo: 
1046   0685             	.db		"SD Mapper flash programmer utility"
1046   0685 5344204D617070657220666C6173682070726F6772616D6D6572207574696C69
1046   06A5 7479
1047   06A7 0D 0A       	.db		13, 10
1048   06A9             	.db		"(c) 2014 by Fabio Belavenuto"
1048   06A9 286329203230313420627920466162696F2042656C6176656E75746F
1049   06C5             	; fall throw
1050   06C5             
1051   06C5             strCrLf: 
1052   06C5 0D 0A 24    	.db		13, 10, '$'
1053   06C8             
1054   06C8             strHelp: 
1055   06C8 0D 0A       	.db		13, 10
1056   06CA             	.db		"Usage:", 13, 10
1056   06CA 55736167653A0D0A
1057   06D2             	.db		"     sdmupd /opts <filename.ext>", 13, 10
1057   06D2 202020202073646D757064202F6F707473203C66696C656E616D652E6578743E
1057   06F2 0D0A
1058   06F4             	.db		"Example: sdmupd DRIVER.ROM", 13, 10
1058   06F4 4578616D706C653A2073646D757064204452495645522E524F4D0D0A
1059   0710             	.db		"         sdmupd /e", 13, 10
1059   0710 20202020202020202073646D757064202F650D0A
1060   0724 0D 0A       	.db		13, 10
1061   0726             	.db		"Options:", 13, 10
1061   0726 4F7074696F6E733A0D0A
1062   0730             	.db		"     /h : Show this help.", 13, 10
1062   0730 20202020202F68203A2053686F7720746869732068656C702E0D0A
1063   074B             	.db		"     /l : Show list of supported chips.", 13, 10
1063   074B 20202020202F6C203A2053686F77206C697374206F6620737570706F72746564
1063   076B 2063686970732E0D0A
1064   0774             	.db		"     /e : Only erase flash and exit.", 13, 10
1064   0774 20202020202F65203A204F6E6C7920657261736520666C61736820616E642065
1064   0794 7869742E0D0A
1065   079A 24          	.db		'$'
1066   079B             
1067   079B             strProcuraFlash: 
1068   079B             	.db		"Searching SD Mapper in system ...", 13, 10
1068   079B 536561726368696E67205344204D617070657220696E2073797374656D202E2E
1068   07BB 2E0D0A
1069   07BE 24          	.db		'$'
1070   07BF             
1071   07BF             strNaoAchado: 
1072   07BF             	.db		"Oops! SD Mapper not Found!!", 13, 10
1072   07BF 4F6F707321205344204D6170706572206E6F7420466F756E6421210D0A
1073   07DC 24          	.db		'$'
1074   07DD             
1075   07DD             strAchado: 
1076   07DD             	.db		"Found in slot "
1076   07DD 466F756E6420696E20736C6F7420
1077   07EB             .slot
1078   07EB              
1079   07EB 30          	.db		'0'
1080   07EC             	.db		" subslot "
1080   07EC 20737562736C6F7420
1081   07F5             .subslot: 
1082   07F5 30 3A 0D 0A 	.db		'0:', 13, 10
1083   07F9 24          	.db		'$'
1084   07FA             
1085   07FA             strTraco: 
1086   07FA 20 2D 20 24 	.db		" - $"
1087   07FE             
1088   07FE             strOk: 
1089   07FE             	.db		" OK!", 13, 10
1089   07FE 204F4B210D0A
1090   0804 24          	.db		'$'
1091   0805             
1092   0805             strErro: 
1093   0805 0D 0A       	.db		13, 10
1094   0807             	.db		"ERROR (BDOS)!!!!", 13, 10
1094   0807 4552524F52202842444F5329212121210D0A
1095   0819 24          	.db		'$'
1096   081A             
1097   081A             strErroAbrirArq: 
1098   081A 0D 0A       	.db		13, 10
1099   081C             	.db		"ERROR: Problems opening file ...", 13, 10
1099   081C 4552524F523A2050726F626C656D73206F70656E696E672066696C65202E2E2E
1099   083C 0D0A
1100   083E 24          	.db		'$'
1101   083F             
1102   083F             strTamanhoErrado: 
1103   083F 0D 0A       	.db		13, 10
1104   0841             	.db		"ERROR: File size must be 128KB"
1104   0841 4552524F523A2046696C652073697A65206D757374206265203132384B42
1105   085F 0D 0A 24    	.db		13, 10, '$'
1106   0862             
1107   0862             strAbrirArq: 
1108   0862 0D 0A       	.db		13, 10
1109   0864             	.db		"Open file : "
1109   0864 4F70656E2066696C65203A20
1110   0870             .nomearq: 
1111   0870             	.db		"                "
1111   0870 20202020202020202020202020202020
1112   0880 0D 0A 24    	.db		13, 10, '$'
1113   0883             
1114   0883             strApagarFlash: 
1115   0883 0D 0A       	.db		13, 10
1116   0885             	.db		"Erasing Flash "
1116   0885 45726173696E6720466C61736820
1117   0893 24          	.db		'$'
1118   0894             
1119   0894             strPonto: 
1120   0894 2A 24       	.db		'*$'
1121   0896             
1122   0896             strGravando: 
1123   0896 0D 00 0A 00 	.dw 	13, 10
1124   089A             	.db		"Loading "
1124   089A 4C6F6164696E6720
1125   08A2 24          	.db 	'$'
1126   08A3             
1127   08A3             strErroAoGravarFlash: 
1128   08A3 0D 0A       	.db		13, 10
1129   08A5             	.db		"ERROR: Problems writing Flash ...", 13, 10
1129   08A5 4552524F523A2050726F626C656D732077726974696E6720466C617368202E2E
1129   08C5 2E0D0A
1130   08C8 24          	.db		'$'
1131   08C9             
1132   08C9             strUpdateCompleto: 
1133   08C9 0D 0A       	.db		13, 10
1134   08CB             	.db		"Flash programmed succesfully.", 13, 10
1134   08CB 466C6173682070726F6772616D6D65642073756363657366756C6C792E0D0A
1135   08EA 24          	.db		'$'
1136   08EB             
1137   08EB             strListaCab: 
1138   08EB 0D 0A       	.db		13, 10
1139   08ED             	.db		"List of supported flash chips:", 13, 10
1139   08ED 4C697374206F6620737570706F7274656420666C6173682063686970733A0D0A
1140   090D             	.db		"------------------------------", 13, 10
1140   090D 2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D0D0A
1141   092D 24          	.db		'$'
1142   092E             
1143   092E             ; *** TABLES ***
1144   092E             ; AT49F002    = $1F $07		alg byte
1145   092E             ; AT49F002T   = $1F $08		alg byte
1146   092E             ; AT49(H)F010 = $1F $17		alg byte
1147   092E             ; AT29C010A   = $1F $D5		alg 128-page
1148   092E             ; AM29F010    = $01 $20		alg byte
1149   092E             ; SST29EE010  = $BF $07		alg 128-page
1150   092E             ; SST39SF020  = $BF $B6		alg byte
1151   092E             ; W49F002U/N  = $DA $0B		alg byte
1152   092E             ; W49F002B    = $DA $25		alg byte
1153   092E             ; W39F010     = $DA $A1		alg byte
1154   092E             ; 
1155   092E             
1156   092E             tblFlash: 
1157   092E 1F 07       	.db		$1F, $07
1158   0930 75 09       		.dw strAtmel
1159   0932 8F 09       		.dw strAt49f002
1160   0934 01          		.db ALG_BYTE
1161   0935 1F 08       	.db		$1F, $08
1162   0937 75 09       		.dw strAtmel
1163   0939 98 09       		.dw	strAt49F002t
1164   093B 01          		.db ALG_BYTE
1165   093C 1F 17       	.db		$1F, $17
1166   093E 75 09       		.dw strAtmel
1167   0940 A2 09       		.dw	strAt49f010
1168   0942 01          		.db ALG_BYTE
1169   0943 1F D5       	.db		$1F, $D5
1170   0945 75 09       		.dw strAtmel
1171   0947 AB 09       		.dw strAt29c010a
1172   0949 02          		.db ALG_PAGE
1173   094A 01 20       	.db		$01, $20
1174   094C 7C 09       		.dw strAMD
1175   094E B5 09       		.dw	strAm29F010
1176   0950 01          		.db	ALG_BYTE
1177   0951 BF 07       	.db		$BF, $07
1178   0953 81 09       		.dw	strSST
1179   0955 BE 09       		.dw	strSst29ee010
1180   0957 02          		.db	ALG_PAGE
1181   0958 BF B6       	.db		$BF, $B6
1182   095A 81 09       		.dw	strSST
1183   095C C9 09       		.dw	strSst39sf020
1184   095E 01          		.db	ALG_BYTE
1185   095F DA 0B       	.db		$DA, $0B
1186   0961 86 09       		.dw	strWinb
1187   0963 D4 09       		.dw	strW49f002un
1188   0965 01          		.db	ALG_BYTE
1189   0966 DA 25       	.db		$DA, $25
1190   0968 86 09       		.dw	strWinb
1191   096A DF 09       		.dw	strW49f002b
1192   096C 01          		.db	ALG_BYTE
1193   096D DA A1       	.db		$DA, $A1
1194   096F 86 09       		.dw	strWinb
1195   0971 E8 09       		.dw	strW39f010
1196   0973 01          		.db	ALG_BYTE
1197   0974 00          	.db		0
1198   0975             
1199   0975             strAtmel: 
1200   0975             	.db		"Atmel $"
1200   0975 41746D656C2024
1201   097C             strAMD: 
1202   097C 414D442024  	.db		"AMD $"
1203   0981             strSST: 
1204   0981 5353542024  	.db		"SST $"
1205   0986             strWinb: 
1206   0986             	.db		"Winbond $"
1206   0986 57696E626F6E642024
1207   098F             strAt49f002: 
1208   098F             	.db		"AT49F002$"
1208   098F 415434394630303224
1209   0998             strAt49F002t: 
1210   0998             	.db		"AT49F002T$"
1210   0998 41543439463030325424
1211   09A2             strAt49f010: 
1212   09A2             	.db		"AT49F010$"
1212   09A2 415434394630313024
1213   09AB             strAt29c010a: 
1214   09AB             	.db		"AT29C010A$"
1214   09AB 41543239433031304124
1215   09B5             strAm29F010: 
1216   09B5             	.db		"AM29F010$"
1216   09B5 414D32394630313024
1217   09BE             strSst29ee010: 
1218   09BE             	.db		"SST29EE010$"
1218   09BE 5353543239454530313024
1219   09C9             strSst39sf020: 
1220   09C9             	.db		"SST39SF020$"
1220   09C9 5353543339534630323024
1221   09D4             strW49f002un: 
1222   09D4             	.db		"W49F002U/N$"
1222   09D4 57343946303032552F4E24
1223   09DF             strW49f002b: 
1224   09DF             	.db		"W49F002B$"
1224   09DF 573439463030324224
1225   09E8             strW39f010: 
1226   09E8             	.db		"W39F010$"
1226   09E8 5733394630313024
1227   09F0             
1228   09F0             ; *** VARIABLES ***
1229   09F0             
1230   09F0 00 00       savesp: 			.dw	0					; stack pointer
1231   09F2 00          savecpu: 		.db	0					; cpu mode in Turbo R
1232   09F3 00          savecursor: 		.db	0					; cursor
1233   09F4 00          dos: 			.db	0					; dos version
1234   09F5 00          system: 			.db	0					; msx version
1235   09F6 00          options: 		.db	0					; options variable 1
1236   09F7 00          pages: 			.db	0					; 16 Kb Pages
1237   09F8 00          actualpage: 		.db	0					; Temporal page for load
1238   09F9 FF          thisslt: 		.db	0FFh				; sigslot flag
1239   09FA 00          flashslt: 		.db	0					; slot for flash
1240   09FB 00          flashIdMan: 		.db 0					; Flash Manufacturer ID
1241   09FC 00          flashIdProd: 	.db 0					; Flash Product ID
1242   09FD 00          flashAlg		.db 0					; Flash algorithm
1243   09FE 00 00       flashManPoint: 	.dw 0					; Flash manufacturer string pointer
1244   0A00 00 00       flashProdPoint: 	.dw	0					; Flash product string pointer
1245   0A02 00          erasedelay: 		.db	0					; tmp variable for loop times delay
1246   0A03 00          togglebit: 		.db 0
1247   0A04 00          sizefiletmp: 	.ds	4					; tmp variable for READMAX Code
1248   0A08 00          fileHandle: 		.db	0					; DOS 2 File Handle
1249   0A09 00          fileNameDOS2: 	.ds	64					; Tmp for fileName
1250   0A49             fileNameDOS1: 	.db "        "			; DOS1 fileName for DOS1 Code
1250   0A49 2020202020202020
1251   0A51 20 20 20    filenDOS1Ext: 	.db	"   "
1252   0A54 00          				.ds	4
1253   0A58             
1254   0A58             ; *** FCB DOS 1 ***
1255   0A58             FCB: 
1256   0A58 00          unidad: 		.db	0
1257   0A59 00          fileName: 	.ds	8
1258   0A61 00          extname: 	.ds	3
1259   0A64 00 00       			.dw	0
1260   0A66 00 00       registro: 	.dw	0
1261   0A68 00          sizefile: 	.ds	4
1262   0A6C 00          			.ds	13
1263   0A79             sizeread: 
1264   0A79 00          			.ds	4
1265   0A7D 00          			.db	0
1266   0A7E             
